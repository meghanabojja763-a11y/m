# -*- coding: utf-8 -*-
"""p

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_i3eYFHrxmZO-pon_fGUx6Uyrrn_eSuy
"""

!pip install scikit-learn
!pip install streamlit
!pip install streamlit_jupyter

import streamlit as st
import pandas as pd
from sklearn.neighbors import NearestNeighbors
from sklearn.preprocessing import MultiLabelBinarizer

# Load employee and project CSV files uploaded via sidebar
employee_file_upload = st.sidebar.file_uploader("Upload Employee CSV", type=["csv"])
project_file_upload = st.sidebar.file_uploader("Upload Project CSV", type=["csv"])

if employee_file_upload and project_file_upload:
    employees = pd.read_csv(employee_file_upload)
    projects = pd.read_csv(project_file_upload)

    # Assuming project DataFrame sorted by deadline
    projects_sorted = projects.sort_values(by='Deadline').reset_index(drop=True)

    # Convert skills strings to list of skills
    def skills_to_list(skills_str):
        return [s.strip().lower() for s in skills_str.split(',')] if isinstance(skills_str, str) else []

    employee_skills_list = employees['skills'].apply(skills_to_list)
    project_skills_list = projects_sorted['Skills Required'].apply(skills_to_list)

    # Fit MultiLabelBinarizer on employees skills and transform both employee and project skills
    mlb = MultiLabelBinarizer()
    employee_skill_vectors = mlb.fit_transform(employee_skills_list)
    project_skill_vectors = mlb.transform(project_skills_list)

    # Build KNN model using Jaccard distance for binary vectors
    knn_model = NearestNeighbors(n_neighbors=1, metric='jaccard')
    knn_model.fit(employee_skill_vectors)

    # Initialize assignment tracking
    assigned_ids = set()
    employee_project_map = {}
    assignments = []

    for i, task_skill_vec in enumerate(project_skill_vectors):
        # Find nearest employee
        distances, indices = knn_model.kneighbors([task_skill_vec])
        nearest_idx = indices[0][0]
        nearest_employee_id = employees.iloc[nearest_idx]['EmployeeID']

        # Assign if available and not already assigned to the same project
        if (nearest_employee_id not in assigned_ids and
            projects_sorted.loc[i, 'Project Name'] not in employee_project_map.get(nearest_employee_id, set())):
            assigned_employee = nearest_employee_id
            employee_project_map.setdefault(assigned_employee, set()).add(projects_sorted.loc[i, 'Project Name'])
            assigned_ids.add(assigned_employee)
        else:
            assigned_employee = None

        assignments.append({
            'Project Name': projects_sorted.loc[i, 'Project Name'],
            'Deadline': projects_sorted.loc[i, 'Deadline'],
            'Sub Task': projects_sorted.loc[i, 'Sub Task'],
            'Skills Required': projects_sorted.loc[i, 'Skills Required'],
            'Assigned EmployeeID': assigned_employee
        })

    df_assignments = pd.DataFrame(assignments)
    st.success("✅ Assignments completed.")
    st.dataframe(df_assignments)

else:
    st.warning("Please upload both Employee and Project CSV files.")

import pandas as pd
from sklearn.neighbors import NearestNeighbors
from sklearn.preprocessing import MultiLabelBinarizer

# Load employee and project CSV files uploaded via sidebar
employee_file_upload = st.sidebar.file_uploader("Upload Employee CSV", type=["csv"])
project_file_upload = st.sidebar.file_uploader("Upload Project CSV", type=["csv"])

if employee_file_upload and project_file_upload:
    employees = pd.read_csv(employee_file_upload)
    projects = pd.read_csv(project_file_upload)

    # Assuming project DataFrame sorted by deadline
    projects_sorted = projects.sort_values(by='Deadline').reset_index(drop=True)

    # Convert skills strings to list of skills
    def skills_to_list(skills_str):
        return [s.strip().lower() for s in skills_str.split(',')] if isinstance(skills_str, str) else []

    employee_skills_list = employees['skills'].apply(skills_to_list)
    project_skills_list = projects_sorted['Skills Required'].apply(skills_to_list)

    # Fit MultiLabelBinarizer on employees skills and transform both employee and project skills
    mlb = MultiLabelBinarizer()
    employee_skill_vectors = mlb.fit_transform(employee_skills_list)
    project_skill_vectors = mlb.transform(project_skills_list)

    # Build KNN model using Jaccard distance for binary vectors
    knn_model = NearestNeighbors(n_neighbors=1, metric='jaccard')
    knn_model.fit(employee_skill_vectors)

    # Initialize assignment tracking
    assigned_ids = set()
    employee_project_map = {}
    assignments = []

    for i, task_skill_vec in enumerate(project_skill_vectors):
        # Find nearest employee
        distances, indices = knn_model.kneighbors([task_skill_vec])
        nearest_idx = indices[0][0]
        nearest_employee_id = employees.iloc[nearest_idx]['EmployeeID']

        # Assign if available and not already assigned to the same project
        if (nearest_employee_id not in assigned_ids and
            projects_sorted.loc[i, 'Project Name'] not in employee_project_map.get(nearest_employee_id, set())):
            assigned_employee = nearest_employee_id
            employee_project_map.setdefault(assigned_employee, set()).add(projects_sorted.loc[i, 'Project Name'])
            assigned_ids.add(assigned_employee)
        else:
            assigned_employee = None

        assignments.append({
            'Project Name': projects_sorted.loc[i, 'Project Name'],
            'Deadline': projects_sorted.loc[i, 'Deadline'],
            'Sub Task': projects_sorted.loc[i, 'Sub Task'],
            'Skills Required': projects_sorted.loc[i, 'Skills Required'],
            'Assigned EmployeeID': assigned_employee
        })

    df_assignments = pd.DataFrame(assignments)
    st.success("✅ Assignments completed.")
    st.dataframe(df_assignments)

else:
    st.warning("Please upload both Employee and Project CSV files.")